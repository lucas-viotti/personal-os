# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
name: Daily Briefing

# AI-powered morning briefing with task focus recommendations
# Requires secrets: ATLASSIAN_*, LLM_*, SLACK_*

on:
  schedule:
    # 9:00 AM BRT (12:00 UTC) Mon-Fri
    - cron: '0 12 * * 1-5'
  workflow_dispatch:

env:
  # LLM Model (can be overridden via secret LLM_MODEL)
  LLM_MODEL: "gpt-4o-mini"

jobs:
  daily-briefing:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # ============================================
      # STEP 1: GATHER DATA
      # ============================================
      
      - name: Fetch Jira Activity
        id: jira
        continue-on-error: true
        env:
          ATLASSIAN_DOMAIN: ${{ secrets.ATLASSIAN_DOMAIN }}
          ATLASSIAN_EMAIL: ${{ secrets.ATLASSIAN_EMAIL }}
          ATLASSIAN_API_TOKEN: ${{ secrets.ATLASSIAN_API_TOKEN }}
          JIRA_PROJECT: ${{ secrets.JIRA_PROJECT }}
        run: |
          if [ -z "$ATLASSIAN_DOMAIN" ] || [ -z "$JIRA_PROJECT" ]; then
            echo "jira_data=_Jira not configured_" >> $GITHUB_OUTPUT
            echo "jira_count=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Fetching Jira activity from $ATLASSIAN_DOMAIN..."
          
          # Use new Jira API endpoint (POST /rest/api/3/search/jql)
          # Filter to issues where user is assignee, reporter, or watcher (mentioned)
          JQL="project = ${JIRA_PROJECT} AND (assignee = \"${ATLASSIAN_EMAIL}\" OR reporter = \"${ATLASSIAN_EMAIL}\" OR watcher = \"${ATLASSIAN_EMAIL}\") AND updated >= -24h ORDER BY updated DESC"
          
          echo "JQL: $JQL"
          
          # Create JSON payload for POST request
          JSON_PAYLOAD=$(jq -n \
            --arg jql "$JQL" \
            '{
              "jql": $jql,
              "maxResults": 20,
              "fields": ["key", "summary", "status", "assignee", "updated"]
            }')
          
          echo "Payload: $JSON_PAYLOAD"
          
          JIRA_RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" \
            -X POST \
            -u "${ATLASSIAN_EMAIL}:${ATLASSIAN_API_TOKEN}" \
            -H "Content-Type: application/json" \
            "https://${ATLASSIAN_DOMAIN}/rest/api/3/search/jql" \
            -d "$JSON_PAYLOAD")
          
          # Extract HTTP code and response body
          HTTP_CODE=$(echo "$JIRA_RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)
          RESPONSE_BODY=$(echo "$JIRA_RESPONSE" | grep -v "HTTP_CODE:")
          
          echo "HTTP Code: $HTTP_CODE"
          echo "Response: ${RESPONSE_BODY:0:500}"
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "Jira API error: HTTP $HTTP_CODE"
            echo "jira_data=_Jira API error_" >> $GITHUB_OUTPUT
            echo "jira_count=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          JIRA_COUNT=$(echo "$RESPONSE_BODY" | jq -r '.issues | length' 2>/dev/null || echo "0")
          
          # Get issue list for AI to summarize (key, summary, status)
          JIRA_RAW=$(echo "$RESPONSE_BODY" | jq -r '.issues[]? | "\(.key): \(.fields.summary) [\(.fields.status.name)]"' 2>/dev/null || echo "")
          
          # Create formatted version with Slack hyperlinks for thread
          JIRA_LINKED=$(echo "$RESPONSE_BODY" | jq -r --arg domain "$ATLASSIAN_DOMAIN" \
            '.issues[]? | "‚Ä¢ <https://\($domain)/browse/\(.key)|\(.key)>: \(.fields.summary | if length > 60 then .[:57] + "..." else . end) [\(.fields.status.name)]"' 2>/dev/null || echo "")
          
          echo "Found $JIRA_COUNT issues"
          
          if [ -z "$JIRA_RAW" ] || [ "$JIRA_COUNT" = "0" ]; then
            JIRA_RAW="_No Jira activity in the last 24h_"
            JIRA_LINKED="_No Jira activity in the last 24h_"
          fi
          
          # Output raw data for AI to summarize
          echo "jira_raw<<EOF" >> $GITHUB_OUTPUT
          echo "$JIRA_RAW" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Output linked version for thread
          echo "jira_linked<<EOF" >> $GITHUB_OUTPUT
          echo "$JIRA_LINKED" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "jira_count=$JIRA_COUNT" >> $GITHUB_OUTPUT

      - name: Fetch Confluence Activity
        id: confluence
        continue-on-error: true
        env:
          ATLASSIAN_DOMAIN: ${{ secrets.ATLASSIAN_DOMAIN }}
          ATLASSIAN_EMAIL: ${{ secrets.ATLASSIAN_EMAIL }}
          ATLASSIAN_API_TOKEN: ${{ secrets.ATLASSIAN_API_TOKEN }}
          CONFLUENCE_SPACES: ${{ secrets.CONFLUENCE_SPACES }}
        run: |
          if [ -z "$ATLASSIAN_DOMAIN" ] || [ -z "$CONFLUENCE_SPACES" ]; then
            echo "confluence_data=_Confluence not configured_" >> $GITHUB_OUTPUT
            echo "confluence_count=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Fetching Confluence activity..."
          
          # Get recently modified pages across spaces
          ALL_PAGES=""
          TOTAL_COUNT=0
          
          for SPACE in $(echo $CONFLUENCE_SPACES | tr ',' ' '); do
            RESPONSE=$(curl -s -u "${ATLASSIAN_EMAIL}:${ATLASSIAN_API_TOKEN}" \
              "https://${ATLASSIAN_DOMAIN}/wiki/rest/api/content?spaceKey=${SPACE}&expand=history.lastUpdated&limit=10&orderby=history.lastUpdated%20desc" \
              2>/dev/null || echo '{"results":[]}')
            
            # Get pages modified in last 24h
            YESTERDAY=$(date -u -d '24 hours ago' +%Y-%m-%dT%H:%M:%S 2>/dev/null || date -u -v-24H +%Y-%m-%dT%H:%M:%S)
            PAGES=$(echo "$RESPONSE" | jq -r --arg yesterday "$YESTERDAY" \
              '.results[]? | select(.history.lastUpdated.when > $yesterday) | "‚Ä¢ \(.title)"' 2>/dev/null || echo "")
            
            if [ -n "$PAGES" ]; then
              ALL_PAGES="${ALL_PAGES}${PAGES}\n"
              COUNT=$(echo "$PAGES" | grep -c "‚Ä¢" || echo "0")
              TOTAL_COUNT=$((TOTAL_COUNT + COUNT))
            fi
          done
          
          if [ -z "$ALL_PAGES" ] || [ "$TOTAL_COUNT" = "0" ]; then
            ALL_PAGES="_No Confluence edits in the last 24h_"
          fi
          
          echo "confluence_data<<EOF" >> $GITHUB_OUTPUT
          echo -e "$ALL_PAGES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "confluence_count=$TOTAL_COUNT" >> $GITHUB_OUTPUT

      # Note: Slack message fetching requires user token (restricted in many companies)
      # For full Slack access, use the local script: scripts/logbook-local.py
      # It can leverage Slack MCP OAuth tokens for unrestricted access

      - name: Read Current Tasks
        id: tasks
        run: |
          TODAY=$(date +'%Y-%m-%d')
          
          # Count by priority
          P0_COUNT=$(grep -l "priority: P0" Tasks/*.md 2>/dev/null | wc -l | tr -d ' ')
          P1_COUNT=$(grep -l "priority: P1" Tasks/*.md 2>/dev/null | wc -l | tr -d ' ')
          BLOCKED_COUNT=$(grep -l "status: b" Tasks/*.md 2>/dev/null | wc -l | tr -d ' ')
          
          # Get P0 tasks - separated by status (no emoji on each line)
          # Skip blocked tasks from active lists
          P0_NOT_STARTED=""
          P0_IN_PROGRESS=""
          for file in $(grep -l "priority: P0" Tasks/*.md 2>/dev/null || echo ""); do
            TITLE=$(grep "^title:" "$file" | sed 's/title: //' | head -1)
            STATUS=$(grep "^status:" "$file" | sed 's/status: //' | head -1)
            # Skip blocked tasks - they go to blocked section
            [ "$STATUS" = "b" ] && continue
            case $STATUS in
              n) P0_NOT_STARTED="${P0_NOT_STARTED}‚Ä¢ ${TITLE}\n" ;;
              s|ip) P0_IN_PROGRESS="${P0_IN_PROGRESS}‚Ä¢ ${TITLE}\n" ;;
            esac
          done
          
          # Get P1 tasks - separated by status (no emoji on each line)
          # Skip blocked tasks from active lists
          P1_NOT_STARTED=""
          P1_IN_PROGRESS=""
          for file in $(grep -l "priority: P1" Tasks/*.md 2>/dev/null || echo ""); do
            TITLE=$(grep "^title:" "$file" | sed 's/title: //' | head -1)
            STATUS=$(grep "^status:" "$file" | sed 's/status: //' | head -1)
            # Skip blocked tasks - they go to blocked section
            [ "$STATUS" = "b" ] && continue
            case $STATUS in
              n) P1_NOT_STARTED="${P1_NOT_STARTED}‚Ä¢ ${TITLE}\n" ;;
              s|ip) P1_IN_PROGRESS="${P1_IN_PROGRESS}‚Ä¢ ${TITLE}\n" ;;
            esac
          done
          
          # Get blocked tasks with details (across all priorities)
          BLOCKED_TASKS=""
          for file in $(grep -l "status: b" Tasks/*.md 2>/dev/null || echo ""); do
            TITLE=$(grep "^title:" "$file" | sed 's/title: //' | head -1)
            BLOCKED_BY=$(grep "^blocked_by:" "$file" | sed 's/blocked_by: //' | head -1)
            BLOCKED_EXPECTED=$(grep "^blocked_expected:" "$file" | sed 's/blocked_expected: //' | head -1)
            if [ -n "$BLOCKED_BY" ]; then
              BLOCKED_TASKS="${BLOCKED_TASKS}‚Ä¢ ${TITLE} ‚Äî _blocked by: ${BLOCKED_BY}_"
              if [ -n "$BLOCKED_EXPECTED" ]; then
                BLOCKED_TASKS="${BLOCKED_TASKS} (check ${BLOCKED_EXPECTED})"
              fi
              BLOCKED_TASKS="${BLOCKED_TASKS}\n"
            else
              BLOCKED_TASKS="${BLOCKED_TASKS}‚Ä¢ ${TITLE}\n"
            fi
          done
          
          # Extract detailed context from tasks for AI analysis
          # Include next_action and next_action_due for prioritization
          TASK_DETAILS=""
          ACTIONS_DUE_TODAY=""
          ACTIONS_DUE_WEEK=""
          
          # Calculate week-end date (7 days from today)
          WEEK_END=$(date -d "+7 days" +%Y-%m-%d 2>/dev/null || date -v+7d +%Y-%m-%d)
          echo "Today: $TODAY, Week end: $WEEK_END"
          
          # Process P0 tasks
          for file in $(grep -l "priority: P0" Tasks/*.md 2>/dev/null | head -5 || echo ""); do
            TITLE=$(grep "^title:" "$file" | sed 's/title: //' | head -1)
            STATUS=$(grep "^status:" "$file" | sed 's/status: //' | head -1)
            DUE_DATE=$(grep "^due_date:" "$file" | sed 's/due_date: //' | head -1)
            NEXT_ACTION=$(grep "^next_action:" "$file" | sed 's/next_action: //' | head -1)
            NEXT_ACTION_DUE=$(grep "^next_action_due:" "$file" | sed 's/next_action_due: //' | head -1)
            BLOCKED_BY=$(grep "^blocked_by:" "$file" | sed 's/blocked_by: //' | head -1)
            
            # Extract Context section (first 3 lines after ## Context)
            CONTEXT=$(sed -n '/^## Context/,/^##/{/^## Context/d;/^##/d;p}' "$file" | head -3 | tr '\n' ' ')
            # Extract latest Progress Log entry
            PROGRESS=$(sed -n '/^## Progress Log/,/^##/{/^## Progress Log/d;/^##/d;p}' "$file" | grep "^-" | tail -1)
            
            case $STATUS in
              n) STATUS_EMOJI="üî¥ Not started" ;;
              s|ip) STATUS_EMOJI="üü° In progress" ;;
              b) STATUS_EMOJI="üü† Blocked" ;;
              *) STATUS_EMOJI="‚ö™ Unknown" ;;
            esac
            
            TASK_DETAILS="${TASK_DETAILS}---\nTASK: ${TITLE}\nPRIORITY: P0\nSTATUS: ${STATUS_EMOJI}\nDUE_DATE: ${DUE_DATE}\nNEXT_ACTION: ${NEXT_ACTION}\nNEXT_ACTION_DUE: ${NEXT_ACTION_DUE}\n"
            if [ -n "$BLOCKED_BY" ]; then
              TASK_DETAILS="${TASK_DETAILS}BLOCKED_BY: ${BLOCKED_BY}\n"
            fi
            TASK_DETAILS="${TASK_DETAILS}CONTEXT: ${CONTEXT}\nLATEST: ${PROGRESS}\n"
            
            # Track actions due today or overdue
            if [ -n "$NEXT_ACTION_DUE" ] && [ "$STATUS" != "b" ]; then
              if [ "$NEXT_ACTION_DUE" \<= "$TODAY" ]; then
                ACTIONS_DUE_TODAY="${ACTIONS_DUE_TODAY}‚Ä¢ üö© ${NEXT_ACTION} ‚Äî _${TITLE}_\n"
              elif [ "$NEXT_ACTION_DUE" \<= "$WEEK_END" ]; then
                ACTIONS_DUE_WEEK="${ACTIONS_DUE_WEEK}‚Ä¢ üö© ${NEXT_ACTION} ‚Äî _${TITLE}_ (due ${NEXT_ACTION_DUE})\n"
              fi
            fi
          done
          
          # Process P1 tasks
          for file in $(grep -l "priority: P1" Tasks/*.md 2>/dev/null | head -5 || echo ""); do
            TITLE=$(grep "^title:" "$file" | sed 's/title: //' | head -1)
            STATUS=$(grep "^status:" "$file" | sed 's/status: //' | head -1)
            DUE_DATE=$(grep "^due_date:" "$file" | sed 's/due_date: //' | head -1)
            NEXT_ACTION=$(grep "^next_action:" "$file" | sed 's/next_action: //' | head -1)
            NEXT_ACTION_DUE=$(grep "^next_action_due:" "$file" | sed 's/next_action_due: //' | head -1)
            BLOCKED_BY=$(grep "^blocked_by:" "$file" | sed 's/blocked_by: //' | head -1)
            
            CONTEXT=$(sed -n '/^## Context/,/^##/{/^## Context/d;/^##/d;p}' "$file" | head -3 | tr '\n' ' ')
            PROGRESS=$(sed -n '/^## Progress Log/,/^##/{/^## Progress Log/d;/^##/d;p}' "$file" | grep "^-" | tail -1)
            
            case $STATUS in
              n) STATUS_EMOJI="üî¥ Not started" ;;
              s|ip) STATUS_EMOJI="üü° In progress" ;;
              b) STATUS_EMOJI="üü† Blocked" ;;
              *) STATUS_EMOJI="‚ö™ Unknown" ;;
            esac
            
            TASK_DETAILS="${TASK_DETAILS}---\nTASK: ${TITLE}\nPRIORITY: P1\nSTATUS: ${STATUS_EMOJI}\nDUE_DATE: ${DUE_DATE}\nNEXT_ACTION: ${NEXT_ACTION}\nNEXT_ACTION_DUE: ${NEXT_ACTION_DUE}\n"
            if [ -n "$BLOCKED_BY" ]; then
              TASK_DETAILS="${TASK_DETAILS}BLOCKED_BY: ${BLOCKED_BY}\n"
            fi
            TASK_DETAILS="${TASK_DETAILS}CONTEXT: ${CONTEXT}\nLATEST: ${PROGRESS}\n"
            
            # Track actions due today or overdue
            if [ -n "$NEXT_ACTION_DUE" ] && [ "$STATUS" != "b" ]; then
              if [ "$NEXT_ACTION_DUE" \<= "$TODAY" ]; then
                ACTIONS_DUE_TODAY="${ACTIONS_DUE_TODAY}‚Ä¢ üìå ${NEXT_ACTION} ‚Äî _${TITLE}_\n"
              elif [ "$NEXT_ACTION_DUE" \<= "$WEEK_END" ]; then
                ACTIONS_DUE_WEEK="${ACTIONS_DUE_WEEK}‚Ä¢ üìå ${NEXT_ACTION} ‚Äî _${TITLE}_ (due ${NEXT_ACTION_DUE})\n"
              fi
            fi
          done
          
          # Output counts
          echo "p0_count=$P0_COUNT" >> $GITHUB_OUTPUT
          echo "p1_count=$P1_COUNT" >> $GITHUB_OUTPUT
          echo "blocked_count=$BLOCKED_COUNT" >> $GITHUB_OUTPUT
          
          # Output P0 tasks - separate not started and in progress
          echo "p0_not_started<<EOF" >> $GITHUB_OUTPUT
          echo -e "$P0_NOT_STARTED" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "p0_in_progress<<EOF" >> $GITHUB_OUTPUT
          echo -e "$P0_IN_PROGRESS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Output P1 tasks - separate not started and in progress
          echo "p1_not_started<<EOF" >> $GITHUB_OUTPUT
          echo -e "$P1_NOT_STARTED" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "p1_in_progress<<EOF" >> $GITHUB_OUTPUT
          echo -e "$P1_IN_PROGRESS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "blocked_tasks<<EOF" >> $GITHUB_OUTPUT
          echo -e "$BLOCKED_TASKS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Output detailed task context for AI
          echo "task_details<<EOF" >> $GITHUB_OUTPUT
          echo -e "$TASK_DETAILS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Output actions due today (for AI priority)
          echo "actions_due_today<<EOF" >> $GITHUB_OUTPUT
          echo -e "$ACTIONS_DUE_TODAY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Output actions due this week (not today)
          echo "actions_due_week<<EOF" >> $GITHUB_OUTPUT
          echo -e "$ACTIONS_DUE_WEEK" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # ============================================
      # STEP 2: AI ANALYSIS
      # ============================================
      
      - name: Read Prioritization Rules
        id: priorities
        run: |
          # Read custom prioritization rules if file exists
          if [ -f "Knowledge/prioritization-rules.md" ]; then
            RULES=$(cat Knowledge/prioritization-rules.md)
            echo "Found prioritization rules file"
          else
            RULES="Default: Prioritize by 1) Deadlines 2) Blocking others 3) Goal alignment 4) Quick wins"
            echo "Using default prioritization rules"
          fi
          
          echo "rules<<EOF" >> $GITHUB_OUTPUT
          echo "$RULES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Load Agent Instructions
        id: agents
        run: |
          # Load Workflow Agent instructions
          if [ -f "core/agents/workflow.md" ]; then
            WORKFLOW_AGENT=$(cat core/agents/workflow.md)
            echo "Loaded workflow agent instructions"
          else
            WORKFLOW_AGENT="You are a productivity assistant."
            echo "Using default workflow agent"
          fi
          
          # Load Analyzer Agent instructions
          if [ -f "core/agents/analyzer.md" ]; then
            ANALYZER_AGENT=$(cat core/agents/analyzer.md)
            echo "Loaded analyzer agent instructions"
          else
            ANALYZER_AGENT=""
            echo "No analyzer agent found"
          fi
          
          echo "workflow_agent<<EOF" >> $GITHUB_OUTPUT
          echo "$WORKFLOW_AGENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "analyzer_agent<<EOF" >> $GITHUB_OUTPUT
          echo "$ANALYZER_AGENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Generate AI Summary and Recommendations
        id: ai_analysis
        continue-on-error: true
        env:
          LLM_API_URL: ${{ secrets.LLM_API_URL }}
          LLM_API_KEY: ${{ secrets.LLM_API_KEY }}
          LLM_MODEL_SECRET: ${{ secrets.LLM_MODEL }}
          P0_COUNT: ${{ steps.tasks.outputs.p0_count }}
          P1_COUNT: ${{ steps.tasks.outputs.p1_count }}
          P0_NOT_STARTED: ${{ steps.tasks.outputs.p0_not_started }}
          P0_IN_PROGRESS: ${{ steps.tasks.outputs.p0_in_progress }}
          P1_NOT_STARTED: ${{ steps.tasks.outputs.p1_not_started }}
          P1_IN_PROGRESS: ${{ steps.tasks.outputs.p1_in_progress }}
          BLOCKED_COUNT: ${{ steps.tasks.outputs.blocked_count }}
          BLOCKED_TASKS: ${{ steps.tasks.outputs.blocked_tasks }}
          TASK_DETAILS: ${{ steps.tasks.outputs.task_details }}
          ACTIONS_DUE_TODAY: ${{ steps.tasks.outputs.actions_due_today }}
          ACTIONS_DUE_WEEK: ${{ steps.tasks.outputs.actions_due_week }}
          JIRA_RAW: ${{ steps.jira.outputs.jira_raw }}
          JIRA_COUNT: ${{ steps.jira.outputs.jira_count }}
          CONFLUENCE_DATA: ${{ steps.confluence.outputs.confluence_data }}
          CONFLUENCE_COUNT: ${{ steps.confluence.outputs.confluence_count }}
          PRIORITIZATION_RULES: ${{ steps.priorities.outputs.rules }}
          WORKFLOW_AGENT: ${{ steps.agents.outputs.workflow_agent }}
        run: |
          MODEL="${LLM_MODEL_SECRET:-${{ env.LLM_MODEL }}}"
          
          if [ -z "$LLM_API_KEY" ]; then
            echo "full_report=_AI not configured. Add LLM_API_KEY secret._" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "ü§ñ Using Agent-Based Generation (Phase 4)"
          
          # Build prompt for main message (Tasks + Focus Recommendations)
          # Recent Activity with links will be posted as a thread reply
          read -r -d '' PROMPT << 'PROMPT_END' || true
          You are the Workflow Agent for Personal OS. Generate a Slack daily briefing.

          CRITICAL: Output must be UNDER 2500 characters total.
          Use Slack mrkdwn: *bold*, _italic_, ‚Ä¢ for bullets

          NEW SCHEMA: Each task now has:
          - next_action: The specific action with earliest due date
          - next_action_due: When that action is due
          - blocked_by: Who/what is blocking (if status=blocked)
          
          PRIORITIZATION LOGIC:
          1. FIRST: Tasks with next_action_due TODAY or OVERDUE (highest priority)
          2. THEN: Priority level (P0 > P1)
          3. SKIP: Blocked tasks (show separately in Tracking section)

          Generate this EXACT structure (follow formatting precisely):

          *‚òÄÔ∏è Daily Briefing ‚Äî [TODAY's DATE]*

          *üéØ Actions Due Today*
          [List actions with next_action_due = TODAY or OVERDUE]
          ‚Ä¢ üö© [next_action] ‚Äî _[task name]_ (for P0 critical tasks)
          ‚Ä¢ üìå [next_action] ‚Äî _[task name]_ (for P1 important tasks)
          [If none due today, write: "_No actions due today._"]

          *üìÖ Actions Due This Week*
          [List actions with next_action_due within next 7 days, NOT today]
          ‚Ä¢ üö© [next_action] ‚Äî _[task name]_ (due [date])
          ‚Ä¢ üìå [next_action] ‚Äî _[task name]_ (due [date])
          [If none, skip this section]

          *üö´ Tracking (Blocked)*
          ‚Ä¢ [task name]
          _Blocked by: [who/what]_
          [If no blocked tasks, skip this section]

          ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

          *üí° AI Focus Recommendation*
          Based on your deadlines, priorities, and recent activity:

          ‚Ä¢ üö© *[next_action]* ‚Äî [task name]
          _Due: [date]. [1-2 sentences explaining why this is prioritized.]_

          ‚Ä¢ üìå *[next_action]* ‚Äî [task name]
          _Due: [date]. [1-2 sentences with reasoning.]_

          _üìä See thread for detailed activity (Jira & Confluence) ‚Üí_

          ICONS:
          - üö© = P0 Critical (red flag)
          - üìå = P1 Important (pushpin)
          
          RULES:
          - Focus on next_action fields, not just task titles
          - Blocked tasks go ONLY in Tracking section, NOT in focus recommendations
          - "Blocked by:" goes on its own line under the task name (like "Due:" format)
          - Skip empty sections entirely
          - Recommendations should be max 2-3 items, based on earliest due dates
          PROMPT_END
          
          TODAY=$(date +'%A, %B %d, %Y')
          
          PROMPT="$PROMPT

          TODAY: $TODAY

          RAW DATA TO SUMMARIZE:

          üéØ ACTIONS DUE TODAY OR OVERDUE (prioritize these first):
          $ACTIONS_DUE_TODAY

          üìÖ ACTIONS DUE THIS WEEK (next 7 days, not today):
          $ACTIONS_DUE_WEEK

          BLOCKED TASKS ($BLOCKED_COUNT total):
          $BLOCKED_TASKS

          JIRA ($JIRA_COUNT issues in last 24h):
          $JIRA_RAW

          CONFLUENCE ($CONFLUENCE_COUNT pages):
          $CONFLUENCE_DATA

          DETAILED TASK CONTEXT (includes next_action and next_action_due):
          $TASK_DETAILS
          
          PRIORITIZATION RULES:
          $PRIORITIZATION_RULES"

          API_URL="${LLM_API_URL:-https://api.openai.com}"
          
          echo "Calling LLM to generate full report..."
          
          AI_RESPONSE=$(curl -s -X POST "${API_URL}/v1/chat/completions" \
            -H "Authorization: Bearer $LLM_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$(jq -n --arg prompt "$PROMPT" --arg model "$MODEL" \
              '{
                "model": $model,
                "messages": [{"role": "user", "content": $prompt}],
                "max_tokens": 1200,
                "temperature": 0.5
              }')" 2>&1)
          
          echo "API Response: ${AI_RESPONSE:0:500}"
          
          FULL_REPORT=$(echo "$AI_RESPONSE" | jq -r '.choices[0].message.content // empty' 2>/dev/null)
          
          if [ -z "$FULL_REPORT" ]; then
            ERROR_MSG=$(echo "$AI_RESPONSE" | jq -r '.error.message // empty' 2>/dev/null)
            FULL_REPORT="*‚òÄÔ∏è Daily Briefing ‚Äî $TODAY*\n\n_AI error: ${ERROR_MSG:-unavailable}_\n\nP0: $P0_COUNT | P1: $P1_COUNT | Jira: $JIRA_COUNT issues"
          fi
          
          # Ensure output doesn't exceed Slack limit (truncate if needed)
          if [ ${#FULL_REPORT} -gt 2900 ]; then
            FULL_REPORT="${FULL_REPORT:0:2850}...\n\n_[Truncated - open Cursor for full details]_"
          fi
          
          echo "Report length: ${#FULL_REPORT} chars"
          
          echo "full_report<<EOF" >> $GITHUB_OUTPUT
          echo "$FULL_REPORT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # ============================================
      # STEP 3: BUILD AND SEND REPORT
      # ============================================
      
      - name: Build Slack Messages
        id: report
        env:
          FULL_REPORT: ${{ steps.ai_analysis.outputs.full_report }}
          JIRA_LINKED: ${{ steps.jira.outputs.jira_linked }}
          JIRA_COUNT: ${{ steps.jira.outputs.jira_count }}
          CONFLUENCE_DATA: ${{ steps.confluence.outputs.confluence_data }}
          CONFLUENCE_COUNT: ${{ steps.confluence.outputs.confluence_count }}
        run: |
          # Main message (AI-generated)
          if [ -n "$FULL_REPORT" ]; then
            echo "main_message<<EOF" >> $GITHUB_OUTPUT
            echo "$FULL_REPORT" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            REPORT="*‚òÄÔ∏è Daily Briefing ‚Äî $(date +'%A, %B %d, %Y')*\n\n_AI report generation failed. Check workflow logs._"
            echo "main_message<<EOF" >> $GITHUB_OUTPUT
            echo -e "$REPORT" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi
          
          # Thread reply with detailed Jira activity (with hyperlinks)
          THREAD="*üìä Recent Activity Details (24h)*\n\n"
          THREAD+="*üìã Jira (${JIRA_COUNT} issues)*\n"
          THREAD+="${JIRA_LINKED}\n"
          
          if [ "${CONFLUENCE_COUNT:-0}" -gt 0 ]; then
            THREAD+="\n*üìù Confluence*\n"
            THREAD+="${CONFLUENCE_DATA}"
          fi
          
          echo "thread_message<<EOF" >> $GITHUB_OUTPUT
          echo -e "$THREAD" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Send Main Message to Slack
        id: slack_main
        uses: slackapi/slack-github-action@v1.27.0
        with:
          channel-id: ${{ secrets.SLACK_CHANNEL_ID }}
          payload: |
            {
              "text": "Daily Briefing",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": ${{ toJSON(steps.report.outputs.main_message) }}
                  }
                }
              ]
            }
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

      - name: Send Activity Thread Reply
        if: steps.slack_main.outputs.ts != ''
        uses: slackapi/slack-github-action@v1.27.0
        with:
          channel-id: ${{ secrets.SLACK_CHANNEL_ID }}
          payload: |
            {
              "thread_ts": "${{ steps.slack_main.outputs.ts }}",
              "text": "Recent Activity Details",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": ${{ toJSON(steps.report.outputs.thread_message) }}
                  }
                }
              ]
            }
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
